"""
Slightly modified version of https://github.com/michaelkirker/excel2latexviapython/blob/master/e2lvp.py

"""

import openpyxl  # Package for reading excel files (.xlsx) into Python
# from itertools import compress
import re  # For reading and processing text strings
from decimal import Decimal


def _is_number(s):
    """
    This function tells us if the object "s" is a number or not.

    This is useful for working out if the excel cell contains a number, and hence whether we need to check how many d.p.
    to round to. It checks by trying to convert the string to a float. If it fails, "s" is not a number

    Args:
        s: [string]

    Returns:
        True/False: Answers if "s" is a string containing only a number
    """

    try:
        float(s)
        return True
    except ValueError:
        return False


def _cell_is_value(s):
    """
    We only want to round numbers in the table if it is comes from a cell that is only a number, and not from any
    potential table headers cells than contain a number. So check to see if the cell contains only numbers, decimal
    points, parenthesis, asterisk. In which case, return yes. These other terms are included as often tables report
    standard errors in parenthesis or include asterisk to denote statistical significance.

    I added "e" and "E" into the list of characters to allow for scientific notation. Currently the code rounds off
    scientific notation to the specified number of DPs. Should probably create a setting to allow for scientific
    notation to be preserved.

    :param s: string of a number that is to be rounded
    :return: True/False: Answers if "s" is from a cell primarily a number
    """

    search_fun = re.compile(r'[^0-9*.()+-eE]').search
    return not bool(search_fun(s))


def _clean_cell_str(s):
    """
    Sometimes (especially if the excel spreadsheet is generated by another program), cells contents are actually
    formatted as [="CONTENTS"]. If this is the case, we want to return only the CONTENTS and not the =" at the start
    or " at the end.

    Args:
        s: [string]

    Returns:
        string containing only the true content of the cell
    """

    if re.search('=".*"', s):
        return s[2:-1]
    else:
        return s


# from https://docs.python.org/3/library/decimal.html#recipes
def moneyfmt(value, places=2, curr='', sep=',', dp='.',
             pos='', neg='-', trailneg=''):
    """Convert Decimal to a money formatted string.

    places:  required number of places after the decimal point
    curr:    optional currency symbol before the sign (may be blank)
    sep:     optional grouping separator (comma, period, space, or blank)
    dp:      decimal point indicator (comma or period)
             only specify as blank when places is zero
    pos:     optional sign for positive numbers: '+', space or blank
    neg:     optional sign for negative numbers: '-', '(', space or blank
    trailneg:optional trailing minus indicator:  '-', ')', space or blank

    >>> d = Decimal('-1234567.8901')
    >>> moneyfmt(d, curr='$')
    '-$1,234,567.89'
    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')
    '1.234.568-'
    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')
    '($1,234,567.89)'
    >>> moneyfmt(Decimal(123456789), sep=' ')
    '123 456 789.00'
    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')
    '<0.02>'

    """
    q = Decimal(10) ** -places      # 2 places --> '0.01'
    sign, digits, exp = value.quantize(q).as_tuple()
    result = []
    digits = list(map(str, digits))
    build, next = result.append, digits.pop
    if sign:
        build(trailneg)
    for i in range(places):
        build(next() if digits else '0')
    if places:
        build(dp)
    if not digits:
        build('0')
    i = 0
    while digits:
        build(next())
        i += 1
        if i == 3 and digits:
            i = 0
            build(sep)
    build(curr)
    build(neg if sign else pos)
    return ''.join(reversed(result))


def _reformat_cellval(cell):
    # Reformat a number of the form 
    # [$-NNCCLLLL]#,##0.00 (see also https://help.libreoffice.org/Common/Number_Format_Codes)
    # We ignore the (Extended) LCID for now
    # Surprised there is no Pandas function for this? Not searched well enough?
    
    try:
        cval = float(cell.value)
    except:
        return cell.value  # if not a number then return
    
    thsep = ''
    currsym = ''
    # lcid = ''
    decsep = '.'
    decp = ''
    
    nf = cell.number_format
    
    nff = nf.split(';')[0] # handle only first fragment, e.g. if separate fragments for negatives
                           # TODO: in fact we should use this for colouring too, but this requires major refactoring...
    
    # check for scientific format
    m = re.findall(r'(\d*)\.(\d*)[Ee]\+(\d*)', nff)
    if len(m) > 0:
        # lz = len(m[0][0]) # apparently not supported in normal exp notation
        dp = len(m[0][1])
        # ep = len(m[0][2]) # apparently not supported in normal exp notation
        fmt = '{:.%sE}'%dp
        return fmt.format(cval)
    
    m = re.findall(r'#\\?(.?)#', nff) # is this robust? Apparently if thsep == ' it may be escaped...
    if len(m) > 0:
        thsep = m[0] # is this true?
    
    # the normal coding is like '[$-809]#,##0.00', where $ does not mean currency
    # a coding with currency looks like '[$-809][$€]#,##0.00'
    # so we only execute the currency part if we find two bracketed expressions...
    m = re.findall(r'\[(\$.?)', nff)
    if len(m) > 1:
        curr = m[-1:][0]
        currsym = curr[-1:]  # either e.g. $€ or just $ (?)
    
    # m = re.findall('\[\$.?-([0-F]*)\]', nff) # we currently don't use this
    # if len(m) > 0:
    #    lcid = m[0]
    
    m = re.findall(r'.?[0-9]?([,.\s]{1})([0-9]*)', nff)
    if len(m) > 0:
        decsep, decp = m[-1:][0]
    
    numdec = len(decp)
    
    # a sanity check (force different thsep and decsep):
    if thsep == decsep:
        if thsep != '.':
            decsep = '.'
        else:
            decsep = ','
    
    # now combine everything
    ret = moneyfmt(Decimal(cval), numdec, currsym, thsep, decsep)
    
    return ret
    


def _tuple2latexstring(row_tup, usr_settings, merge_list):
    """
    This function converts a tuple of openpyxl CELLs into a single row string
    of LaTeX code for inclusion in the table. It loops over each cell and appends
    the appropriate text (representing the LaTeX code) to the string which it
    returns at the end.

    :param row_tup: [tuple] contains the openpyxl CELLs for a single row of the table
    :param usr_settings: [dict] user defined options
    :param merge_list: list of cells in the row that are merged together

    :return: A string of the row cells formatted in the LaTeX style.
    """

    num_elements = len(row_tup)  # how many columns we have in the row

    str_out = ""  # initilise the output string

    merge_start_cols = merge_list[0]
    merge_end_cols = merge_list[1]
    merge_match_det = merge_list[2]

    colidx = 0
    multiidx = 0

    while colidx < num_elements:  # for each column/cell in the tuple for the row

        # Check to see if the column/cell is part of a multicolumn/row

        if colidx in merge_start_cols:
            # Multicolumn/row

            multcol_indx = merge_start_cols.index(colidx)
            value_string = _clean_cell_str(merge_match_det[multcol_indx])

            colidx = merge_end_cols[multcol_indx]

            multiidx += 1

        else:
            # Get the main text for that cell.

            #########
            # Step 1: Get the "value_string" giving the text displayed in the cell
            #########

            if row_tup[colidx].value is None:
                # In this case, the cell is empty, so

                value_string = " "  # Cell is empty of value

            else:  # Case when the cell contains something
                # Get content of cell, and if needed, apply the d.p. rounding rule to the content.

                # ppenguin: we may need to do additional handling of the cell's number format here...
                # in fact, forget about the whole re-formatting and rounding, just ry to translate the number format from the excel file
                # let's try:
                row_tup[colidx].value = _clean_cell_str(str(row_tup[colidx].value))
                value_string = _reformat_cellval(row_tup[colidx])

                #if usr_settings['roundtodp']:

                #   if _cell_is_value(str(row_tup[colidx].value)):
                #        value_string = _round_num_in_str(_clean_cell_str(str(row_tup[colidx].value)),
                #                                        usr_settings['numdp'], usr_settings['thsep'])
                #   else:
                #       value_string = _clean_cell_str(str(row_tup[colidx].value))
                # else:
                #    value_string = _clean_cell_str(str(row_tup[colidx].value))

            #########
            # Step 2: Apply formatting to the cell's value
            #########

            # The cell might have special formatting applied to the value inside it (e.g. bold text).
            # Apply the LaTeX version of this formatting to the string

            # Apply bold font if needed
            if row_tup[colidx].font.__dict__['b']:
                value_string = "\\textbf{" + value_string + "}"

            # Apply italicize if needed
            if row_tup[colidx].font.__dict__['i']:
                value_string = "\\textit{" + value_string + "}"

            # Apply font color
            # apparently (sometimes???) font.color can be None, so check against that
            if row_tup[colidx].font.color is not None:
                if isinstance(row_tup[colidx].font.color.rgb, str):
                    value_string = "\\textcolor[HTML]{" + row_tup[colidx].font.color.rgb[2:] + "}{" + value_string + "}"

            # Cell background color
            if isinstance(row_tup[colidx].fill.start_color.index, int):  # built in color

                # Currently cannot handle this case
                value_string = value_string

            else:

                if row_tup[colidx].fill.start_color.index != '00000000':
                    value_string = "\\cellcolor[HTML]{" + row_tup[colidx].fill.start_color.index[2:] + "}{" + \
                                   value_string + "}"

        #########
        # Step 3: Now that we have to LaTeX code for that cell/column, append it to the string for the entire row.
        #########

        # Append formatted string for this cell to the string out
        str_out += value_string

        # If this isnt the last element, add cell divider
        if colidx < num_elements - 1:
            str_out += " \t & \t "

        colidx += 1

    # Now that we have looped over all elements, add on line ending code for the end of the row string
    str_out += " \\\ \n"

    return str_out


def _check_for_vline(col_tup, loc):
    """
    Look for vertical lines down the entire length of the column.

    We do this by looping over all the cells, and then counting how many of them have a vertical line in location "loc"

    :param col_tup:  [tuple] contains the openpyxl CELLs for a single row of the table
    :param loc: [string] 'top' or 'bottom'
    :return:
    """

    num_rows = len(col_tup)  # Number of rows in the column

    count = 0  # Initialise count

    for rownum in range(0, num_rows):  # For each row

        # Check to see if there is a border style in location "loc"
        if col_tup[rownum].border.__dict__[loc].border_style is not None:
            # Add one to our count
            count += 1

    # Check to see if every row has a border style in location "loc"
    if count == num_rows:
        return True
    else:
        return False


def _create_cline_code(cell_has_rule_bool, booktabs=False):
    """
    Creates the code for horizontal lines that do not span the entire length of the table, only a few cells.

    :param cell_has_rule_bool: [list] whose elements are True/False for each cell indicating whether the horizontal rule
    includes this cell.
    :param booktabs:  True/False. Should the code return code for the booktabs package or regular LaTeX?

    :return: A string containing the code needed to draw the horizontal lines.
    E.g. "\cmidrule(r){1-4} \cmidrule(r){6-9} \n"
    """

    # Initialize the output string
    str_out = ''

    num_column = len(cell_has_rule_bool)  # How many elements in the row

    # Create a flag to indicate whether we are starting a new cmidrule/cline or not.
    look_for_new_crule = True  # we are looking for the next True to start a new \cmidrule or \cline

    for colind in range(0, num_column):  # For each column/cell

        if (cell_has_rule_bool[colind] is True) & (look_for_new_crule is True):
            # The current cell has a cmidrule/cline, and we are looking for the next crule. So start a new rule/line in
            # the LaTeX code

            colnum = colind + 1  # column number is one more than the python index

            # Append new line/rule to str_out
            if booktabs is True:
                str_out += '\\cmidrule(r){' + str(colnum) + '-'
            else:
                str_out += '\\cline{' + str(colnum) + '-'

            # Turn off flag since now we are going to be looking for where this particular cline ends
            look_for_new_crule = False

            continue  # Move on to next table cell

        elif (cell_has_rule_bool[colind] is False) & (look_for_new_crule is True):
            # This is the case when we are searching for a new cline to begin, but the current table cell does not
            # contain a crule, so we carry on looking
            continue

        elif cell_has_rule_bool[colind] is False:
            # We have found a column/cell without a cline (=False), and we are looking to close the currently opened
            # cline/crule as look_for_new_crule=False (because the cases where look_for_new_crule=True are dealt with
            # by the previous elif case). Therefore, we want to add the LaTeX code to close the current crule/cline

            str_out += str(colind) + '} \t '  # colidx = colnum-1, which is the last column to include

            look_for_new_crule = True  # Turn flag back on so we are searching for the next crule start
            continue

        elif (cell_has_rule_bool[colind] is True) & (colind == num_column - 1):
            # If we get to the end of the table, and the column/cell still has a cline, end the cline.
            # last one is True

            str_out += str(num_column) + '} \t '

    # The above cases exhaust all possibilities, so no need for "else" statement

    # End the LaTeX line and return the string
    str_out += ' \n'

    return str_out


def _create_horzrule_code(row_tup, loc, merge_start_cols, merge_end_cols, usr_settings):
    """
    Create LaTeX code for horizontal lines, above or below (defined by 'loc'), that particular row_tup.

    Horizontal lines may either span the entire width of the table, or along a few columns.


    Args:
        row_tup: [tuple] a particular row of cells.

        loc: [string] either 'top' or 'bottom' to indicate where (relative to this particular
                row) we should check for any horizontal lines.

        merge_start_cols: [list] the row numbers related to where merged cells start.

        merge_end_cols: [list] the row numbers related to where merged cells stop.

        usr_settings: [dictionary] user settings - tells us whether to use booktabs code or not.


    Returns:
        A string containing the LaTeX code needed to draw the horizontal line(s) for that particular row.
    """

    num_column = len(row_tup)  # number of columns/elements in this particular row

    # Step 1: Find which cells have horizontal rules
    # Construct a list with True/False elements to indicate if the horizontal rule applies to that cell.

    cell_has_rule = []  # Pre-allocate list

    for colnum in range(0, num_column):  # for each column in the row

        # Check to see if this particular column falls within the span of merged cells
        # If so, we can ignore it, and use the details from the first cell of the merged cells
        cond_1 = [colnum > x for x in merge_start_cols]
        cond_2 = [colnum <= x for x in merge_end_cols]

        cond_combine = []
        for i in range(0, len(cond_1)):
            cond_combine.append(cond_1[i] is True and cond_2[i] is True)

        if any(x is True for x in cond_combine):  # cell is a subsequent merged cell
            cell_has_rule.append(cell_has_rule[-1])

        else:

            if row_tup[colnum].border.__dict__[loc].border_style is not None:
                cell_has_rule.append(True)
            else:
                cell_has_rule.append(False)

    if sum(cell_has_rule) == 0:  # If there are no rules and any cell, there is no line here, so return a blank string

        return ''

    else:  # There exists some horizontal rule on at least part of the row, so return the appropriate LaTeX code

        # If user has specified booktabs
        if usr_settings['booktabs'] is True:

            if sum(cell_has_rule) == num_column:
                return '\midrule \n'
            else:
                return _create_cline_code(cell_has_rule, booktabs=True)

        else:

            if sum(cell_has_rule) == num_column:
                return '\hline \n'
            else:
                return _create_cline_code(cell_has_rule, booktabs=False)


def _get_merged_cells(sheet):
    """
    rewrite of original making indexing easier and additionally enabling multirow
    by ppenguin
    """

    start_row = []
    start_col = []

    end_row = []
    end_col = []

    latex_code = []

    if len(sheet.merged_cell_ranges) == 0:
        return [[], [], [], [], []]  # No merged cells, so return an empty list

    for merge_ in sheet.merged_cell_ranges:  # For each merge in the sheet

        # Split the location string of the merge, and convert it it to an index number (e.g. "A3")
        # ppenguin: this fails on vertically merged cells, since merge_ is a CellRange object then
        # so we need a generic function to get the appropriate coordinates
        # merge_loc_str = re.split(':', merge_)
        if type(merge_) == type(str):
            ts = re.split(':', merge_)
            start_coord = openpyxl.utils.coordinate_to_tuple(ts[0])
            end_coord = openpyxl.utils.coordinate_to_tuple(ts[1])
        else:
            start_coord = (merge_.min_row, merge_.min_col)
            end_coord = (merge_.max_row, merge_.max_col)
            

        start_row.append(start_coord[0] - 1)
        start_col.append(start_coord[1] - 1)

        end_row.append(end_coord[0] - 1)
        end_col.append(end_coord[1] - 1)

        ccell = sheet["%s%d"%(openpyxl.utils.cell.get_column_letter(start_coord[1]), start_coord[0])] 

        value_string = ccell.value

        if ccell.font.__dict__['b']:
            value_string = "\\textbf{" + value_string + "}"

        # Apply italicize if needed
        if ccell.font.__dict__['i']:
            value_string = "\\textit{" + value_string + "}"

        # is it a vertical merge (multirow) or a horizontal one (multicol)?
        # or both??? So why don't we just always define both multicol and multirow, but simply adjust the span,
        # which would be 1 for both in case of a normal cell (which doesn't occur here becaus this code handles merges)
        # Get span of multicolumn
        colspan = end_coord[1] - start_coord[1] + 1
        rowspan = end_coord[0] - start_coord[0] + 1
        # Get alignment
        halign = ccell.alignment.__dict__['horizontal'][0]  # get the first letter
        # vertical alignment in multirow sucks, we need to tweak it with a so-called "fixup"
        fixup = ""
        if rowspan > 1:
            fixup = "[-%0.2fex]"%((rowspan-1)/2+1)
        # e.g. \multicolumn{3}{|l|}{\multirow{3}{*}{mystring}}
        latex_code.append("\multicolumn{%d}{%s}{\multirow{%d}{*}%s{%s}}"%(colspan, halign, rowspan, fixup, value_string))
        # latex_code.append('\multicolumn{' + str(colspan) + '}{' + halign + '}{' + value_string + '}')
        ### TODO we need to handle borders here as well, and vertical alignment

    return [start_row, start_col, end_row, end_col, latex_code]


def _get_merged_cells_old(sheet):
    """
    Locate all the merged cells within a sheet, return the row and column locations of the start and end, and also
    return the LaTeX code for the merged cells.

    :param sheet: [tuple] openpyxl excel worksheet object

    :return: list containing (1) index of the rows of each merged cells first cell, (2) index of the column of each
    merged cell first cell, (3) index of the columns of each moerged cells last cell, (4) index of the column of each
    merged cell last cel, (5) LaTeX code for the
    """

    start_row = []
    start_col = []

    end_row = []
    end_col = []

    latex_code = []

    if len(sheet.merged_cell_ranges) == 0:
        return [[], [], [], [], []]  # No merged cells, so return an empty list

    for merge_ in sheet.merged_cell_ranges:  # For each merge in the sheet

        # Split the location string of the merge, and convert it it to an index number (e.g. "A3")
        # ppenguin: this fails on vertically merged cells, since merge_ is a CellRange object then
        # so we need a generic function to get the appropriate coordinates
        merge_loc_str = re.split(':', merge_)

        # convert string to col/row index numbers
        start_coord = openpyxl.utils.coordinate_to_tuple(merge_loc_str[0])
        end_coord = openpyxl.utils.coordinate_to_tuple(merge_loc_str[1])

        start_row.append(start_coord[0] - 1)
        start_col.append(start_coord[1] - 1)

        end_row.append(end_coord[0] - 1)
        end_col.append(end_coord[1] - 1)

        value_string = sheet[merge_loc_str[0]].value

        if sheet[merge_loc_str[0]].font.__dict__['b']:
            value_string = "\\textbf{" + value_string + "}"

        # Apply italicize if needed
        if sheet[merge_loc_str[0]].font.__dict__['i']:
            value_string = "\\textit{" + value_string + "}"

        # Get span of multicolumn
        multi_col_length = end_coord[1] - start_coord[1] + 1

        # Get alignment
        halign = sheet[merge_loc_str[0]].alignment.__dict__['horizontal'][0]  # get the first letter

        latex_code.append('\multicolumn{' + str(multi_col_length) + '}{' + halign + '}{' + value_string + '}')

    return [start_row, start_col, end_row, end_col, latex_code]


def _pick_col_text_alignment(col_tup):
    """
    For a given column, choose the alignment (left, center, right) based
    on the alignment choice of the majority of the cells


    Args:
        col_tup: [tuple] containing a column of the table.

    Returns:
        A string ('l'/'c'/'r') indicating the alignment to use
    """

    max_column = len(col_tup)

    # Preallocate counters
    count_left = 0
    count_center = 0
    count_right = 0

    # Loop over each row, and count the alignment types
    for rn in range(0, max_column):

        # If the user doesnt speicify an alignment in Excel, we see the alignment
        # choice as "None". So let us assign default values. If a number, align
        # right, if not, align left.

        if col_tup[rn].alignment.__dict__['horizontal'] is None:

            # Check to see if the value is a number
            if col_tup[rn].value is None:
                align_val = 'ignore'
            elif _is_number(col_tup[rn].value):
                align_val = 'right'
            else:
                align_val = 'left'

        else:
            align_val = col_tup[rn].alignment.__dict__['horizontal']

        if align_val in ['left']:

            count_left += 1

        elif align_val in ['center']:

            count_center += 1

        elif align_val in ['right']:

            count_right += 1

    # Find the maximum, in the case of a tie, we break the tie by the order: L,C,R
    max_count = max([count_left, count_center, count_right])

    if count_left == max_count:
        return 'l'
    elif count_center == max_count:
        return 'c'
    elif count_right == max_count:
        return 'r'


# probably need to move to the per-cell level and check whether we can get more formatting info from the xls
def _round_num_in_str(str_in, num_dp, thsep):
    """
    For a given string, round any number to the appropriate number of d.p.

    Args:
        str_in: [string] string containing numbers to round

        num_dp: [scalar] number of decimal places to round each number to

    Returns:
        A string where the numbers in str_in have been rounded.
    """

    str_out = str_in

    # Extract a list of all numbers in the string
    list_found_num_str = re.findall("\d+[.]\d*", str_in)  # Add a question mark behind the "]" to round all numbers
    # (even those without a DP)

    list_found_scientific_num_str = re.findall("\d+[.]*\d*e[+-]\d*", str_in)

    list_found = list_found_num_str + list_found_scientific_num_str

    # Create a list of the found numbers rounded to the appropriate d.p.
    list_nums = [float(s) for s in list_found]

    # was: str_format = '%.' + str(num_dp) + 'f'
    str_format = '{:,.' + str(num_dp) + 'f}'

    for ii in range(0, len(list_found)):
        # For each number found, substitute in the rounded number
        str_out = re.sub(list_found[ii], str_format.format(list_nums[ii]).replace(',',thsep), str_out)

    return str_out


def _all_nones(iterable):
    """
    Tells us if every value within the tuple iterable is None (missing)
    :param iterable:
    :return:
    """

    for element in iterable:
        if element.value is not None:
            return False
    return True


def _get_table_dimensions(sheet):
    """
    The table within the sheet may not start in cell A1. This function finds the location of the table within the sheet
    by looking for the upper-left and bottom-right most cells that have content. It returns the location of these two
    corner cells.

    :param sheet: Excel worksheet object
    :return:    start_row_idx: row number of the upper-left most cell that contains something
                start_col_idx: column number of the upper-left most cell that contains something
                end_row_idx: row number of the bottom-right most cell that contains something
                end_col_idx: column number of the bottom-right most cell that contains something
    """

    # Pre-allocate starting indices
    start_col_idx = 0
    start_row_idx = 0

    # Pre-allocate end indices (adjust for python starting index at zero, and Excel starting at 1)
    end_col_idx = sheet.max_column - 1
    end_row_idx = sheet.max_row - 1

    # Trim off any empty columns at the end of the table
    for col_num in range(sheet.max_column - 1, -1, -1):

        if _all_nones(list(sheet.columns)[col_num]):
            # Trim the column for the sheet
            end_col_idx = end_col_idx - 1
        else:
            # current final column has a value so stop trimming
            break

    # Trim off any empty rows at the end of the table
    for row_num in range(sheet.max_row - 1, -1, -1):

        if _all_nones(list(sheet.rows)[row_num]):
            # Trim the column for the sheet
            end_row_idx = end_row_idx - 1
        else:
            # current final column has value so stop trimming
            break

    # Trim off any empty columns at the start of the table
    for col_num in range(0, sheet.max_column):

        if _all_nones(list(sheet.columns)[col_num]):
            # Trim the column for the sheet
            start_col_idx = start_col_idx + 1
        else:
            # current final column has value so stop trimming
            break

    # Trim off any empty rows at the start of the table
    for row_num in range(0, sheet.max_row):

        if _all_nones(list(sheet.rows)[row_num]):
            # Trim the column for the sheet
            start_row_idx = start_row_idx + 1
        else:
            # current final column has value so stop trimming
            break

    return start_row_idx, start_col_idx, end_row_idx, end_col_idx


def _create_column(table_in, col_idx):
    """
    Takes a table and returns a tuple containing only a single column of the table. Useful for analysing a single
    column of the table


    :param table_in: table to extract column from
    :param col_idx: index of the column to be extracted
    :return: tuple of just column col_idx
    """

    nrows = len(table_in)  # number of rows in the table

    col = []  # preallocate

    for row_num in range(0, nrows):

        col += [table_in[row_num][col_idx]]

    return tuple(col)

