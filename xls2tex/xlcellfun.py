# -*- coding: utf-8 -*-
"""
xlcellfun.py

Created on Mon Mar 30 14:26:34 2020
@author: ppenguin

generic utility functions to for handling/converting excell cells in conjunction with openpyxl
"""

from decimal import Decimal
import re

# from https://docs.python.org/3/library/decimal.html#recipes
def _moneyfmt(value, places=2, curr='', sep=',', dp='.',
             pos='', neg='-', trailneg=''):
    """Convert Decimal to a money formatted string.

    places:  required number of places after the decimal point
    curr:    optional currency symbol before the sign (may be blank)
    sep:     optional grouping separator (comma, period, space, or blank)
    dp:      decimal point indicator (comma or period)
             only specify as blank when places is zero
    pos:     optional sign for positive numbers: '+', space or blank
    neg:     optional sign for negative numbers: '-', '(', space or blank
    trailneg:optional trailing minus indicator:  '-', ')', space or blank

    >>> d = Decimal('-1234567.8901')
    >>> moneyfmt(d, curr='$')
    '-$1,234,567.89'
    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')
    '1.234.568-'
    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')
    '($1,234,567.89)'
    >>> moneyfmt(Decimal(123456789), sep=' ')
    '123 456 789.00'
    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')
    '<0.02>'

    """
    q = Decimal(10) ** -places      # 2 places --> '0.01'
    sign, digits, exp = value.quantize(q).as_tuple()
    result = []
    digits = list(map(str, digits))
    build, next = result.append, digits.pop
    
    if sign:
        build(trailneg)
    
    for i in range(places):
        build(next() if digits else '0')
    
    if places:
        build(dp)
    
    if not digits:
        build('0')
    i = 0
    
    while digits:
        build(next())
        i += 1
        if i == 3 and digits:
            i = 0
            build(sep)
    
    build(curr)
    build(neg if sign else pos)
    
    return ''.join(reversed(result))


def _is_number(s):
    """
    This function tells us if the object "s" is a number or not.

    This is useful for working out if the excel cell contains a number, and hence whether we need to check how many d.p.
    to round to. It checks by trying to convert the string to a float. If it fails, "s" is not a number

    Args:
        s: [string]

    Returns:
        True/False: Answers if "s" is a string containing only a number
    """

    try:
        float(s)
        return True
    except ValueError:
        return False


def _cell_is_value(s):
    """
    We only want to round numbers in the table if it is comes from a cell that is only a number, and not from any
    potential table headers cells than contain a number. So check to see if the cell contains only numbers, decimal
    points, parenthesis, asterisk. In which case, return yes. These other terms are included as often tables report
    standard errors in parenthesis or include asterisk to denote statistical significance.

    I added "e" and "E" into the list of characters to allow for scientific notation. Currently the code rounds off
    scientific notation to the specified number of DPs. Should probably create a setting to allow for scientific
    notation to be preserved.

    :param s: string of a number that is to be rounded
    :return: True/False: Answers if "s" is from a cell primarily a number
    """

    search_fun = re.compile(r'[^0-9*.()+-eE]').search
    return not bool(search_fun(s))


def _clean_cell_str(s):
    """
    Sometimes (especially if the excel spreadsheet is generated by another program), cells contents are actually
    formatted as [="CONTENTS"]. If this is the case, we want to return only the CONTENTS and not the =" at the start
    or " at the end.

    Args:
        s: [string]

    Returns:
        string containing only the true content of the cell
    """

    if re.search('=".*"', s):
        return s[2:-1]
    else:
        return s


def reformat_cellval(cell):
    # Reformat a number of the form 
    # [$-NNCCLLLL]#,##0.00 (see also https://help.libreoffice.org/Common/Number_Format_Codes)
    # We ignore the (Extended) LCID for now
    # Surprised there is no Pandas function for this? Not searched well enough?
    
    if cell.value is None:
        return ""
    
    try:
        cval = float(cell.value)
    except:
        return cell.value  # if not a number then return
    
    thsep = ''
    currsym = ''
    # lcid = ''
    decsep = '.'
    decp = ''
    
    nf = cell.number_format
    
    nff = nf.split(';')[0] # handle only first fragment, e.g. if separate fragments for negatives
                           # TODO: in fact we should use this for colouring too, but this requires major refactoring...
    
    # check for scientific format
    m = re.findall(r'(\d*)\.(\d*)[Ee]\+(\d*)', nff)
    if len(m) > 0:
        # lz = len(m[0][0]) # apparently not supported in normal exp notation
        dp = len(m[0][1])
        # ep = len(m[0][2]) # apparently not supported in normal exp notation
        fmt = '{:.%sE}'%dp
        return fmt.format(cval)
    
    m = re.findall(r'#\\?(.?)#', nff) # is this robust? Apparently if thsep == ' it may be escaped...
    if len(m) > 0:
        thsep = m[0] # is this true?
    
    # the normal coding is like '[$-809]#,##0.00', where $ does not mean currency
    # a coding with currency looks like '[$-809][$€]#,##0.00'
    # so we only execute the currency part if we find two bracketed expressions...
    m = re.findall(r'\[(\$.?)', nff)
    if len(m) > 1:
        curr = m[-1:][0]
        currsym = curr[-1:]  # either e.g. $€ or just $ (?)
    
    # m = re.findall('\[\$.?-([0-F]*)\]', nff) # we currently don't use this
    # if len(m) > 0:
    #    lcid = m[0]
    
    m = re.findall(r'.?[0-9]?([,.\s]{1})([0-9]*)', nff)
    if len(m) > 0:
        decsep, decp = m[-1:][0]
    
    numdec = len(decp)
    
    # a sanity check (force different thsep and decsep):
    if thsep == decsep:
        if thsep != '.':
            decsep = '.'
        else:
            decsep = ','
    
    # now combine everything
    ret = _moneyfmt(Decimal(cval), numdec, currsym, thsep, decsep)
    
    return ret

